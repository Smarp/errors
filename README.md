# Generate

Make enum of error
```go
//go:generate stringer -type=Pill
package errors

type Pill int

const (
	Placebo Pill = iota
	Aspirin
	Ibuprofen
	Paracetamol
	Acetaminophen = Paracetamol
)

```

Run `go generate` to generate string file
```go
// Code generated by "stringer -type=Pill"; DO NOT EDIT

package errors

import "fmt"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
	if i < 0 || i >= Pill(len(_Pill_index)-1) {
		return fmt.Sprintf("Pill(%d)", i)
	}
	return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

# Errors
We then can make error from stringer with `errors.New()`. We can put a map of key and values in addition to the error for debug purpose.  
E.g:
```go
err := New(Placebo, nil)

err := New(Placebo, map[string]interface{}{"Key": "Val"})
```

Or we can wrap go `error`
```go
e := errors.New("Some error")
err := Wrap(e)
```

# Add
We can use `.Add()` to add more error to our error stack.
```go
err := New(Placebo, map[string]interface{}{"Key": "Val"}).
			Add(New(Aspirin, nil)).
			Add(New(Ibuprofen, nil))
```

# Type
To make comparison agaisnt the enumeration we had, use `.Type()`. It will return the type of the first error in the stack.
```go
if err.Type() == Placebo{...}
```
# Printing
`.Error()` will print a list of error with its associated map. For e.g:
```go
err := New(Placebo, nil)
err.Error() //will print "Placebo"

err := New(Placebo, map[string]interface{}{"Key": "Val"})
err.Error() //will print Placebo{Key: Val}

err := New(Placebo, map[string]interface{}{"Key": "Val"}).
			Add(New(Aspirin, nil)).
			Add(New(Ibuprofen, nil))
err.Error() //will print Placebo{Key: Val};Aspirin;Ibuprofen
```
